<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>glitchVR</title>
<style>
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

body {
  background: #000;
  color: #e0e0e0;
  font-family: 'SF Mono', 'Fira Code', 'Cascadia Code', monospace;
  overflow: hidden;
  height: 100dvh;
  width: 100vw;
}

/* ── canvas ── */
canvas { display: block; }

/* ── UI overlay ── */
#ui {
  position: fixed;
  inset: 0;
  display: flex;
  flex-direction: column;
  align-items: center;
  z-index: 10;
  background: rgba(0,0,0,0.92);
  backdrop-filter: blur(8px);
  -webkit-backdrop-filter: blur(8px);
  transition: opacity 0.4s;
  overflow-y: auto;
  padding: 2rem 1rem 4rem;
}
#ui.hidden { opacity: 0; pointer-events: none; }

#ui h1 {
  font-size: 1.1rem;
  font-weight: 400;
  letter-spacing: 0.15em;
  text-transform: uppercase;
  margin-bottom: 1.5rem;
  margin-top: 1rem;
  color: #fff;
  flex-shrink: 0;
}

/* ── video gallery ── */
#gallery {
  width: min(95vw, 720px);
  margin-bottom: 1.5rem;
  flex-shrink: 0;
}
#gallery h2 {
  font-size: 0.7rem;
  font-weight: 400;
  letter-spacing: 0.1em;
  text-transform: uppercase;
  color: #666;
  margin-bottom: 0.8rem;
  padding-left: 0.2rem;
}
.video-list {
  display: flex;
  flex-direction: column;
  gap: 1px;
}
.video-item {
  display: flex;
  align-items: center;
  gap: 0.8rem;
  padding: 0.6rem 0.8rem;
  background: rgba(255,255,255,0.03);
  border: 1px solid transparent;
  border-radius: 4px;
  cursor: pointer;
  transition: all 0.15s;
}
.video-item:hover {
  background: rgba(255,255,255,0.06);
  border-color: #333;
}
.video-item .v-name {
  flex: 1;
  font-size: 0.75rem;
  color: #ccc;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}
.video-item .v-tag {
  font-size: 0.6rem;
  color: #666;
  border: 1px solid #333;
  padding: 0.15rem 0.4rem;
  border-radius: 3px;
  flex-shrink: 0;
}
.video-item .v-size {
  font-size: 0.6rem;
  color: #555;
  flex-shrink: 0;
  min-width: 3rem;
  text-align: right;
}
.video-item .v-quality {
  font-size: 0.55rem;
  padding: 0.1rem 0.35rem;
  border-radius: 2px;
  flex-shrink: 0;
}
.video-item .v-quality.full { color: #7c9; border: 1px solid #3a5; }
.video-item .v-quality.preview { color: #99a; border: 1px solid #556; }

/* ── drop zone ── */
#dropzone {
  width: min(90vw, 480px);
  border: 1px dashed #333;
  border-radius: 8px;
  padding: 1.5rem 1.5rem;
  text-align: center;
  cursor: pointer;
  transition: border-color 0.2s, background 0.2s;
  flex-shrink: 0;
}
#dropzone:hover, #dropzone.dragover {
  border-color: #666;
  background: rgba(255,255,255,0.03);
}
#dropzone p { font-size: 0.75rem; color: #666; line-height: 1.6; }
#dropzone p span { color: #999; }

/* ── layout selector ── */
#controls {
  margin-top: 1rem;
  display: flex;
  gap: 0.5rem;
  flex-wrap: wrap;
  justify-content: center;
  flex-shrink: 0;
}
#controls button {
  background: transparent;
  border: 1px solid #444;
  color: #ccc;
  font-family: inherit;
  font-size: 0.7rem;
  padding: 0.35rem 0.8rem;
  border-radius: 4px;
  cursor: pointer;
  letter-spacing: 0.05em;
  transition: all 0.15s;
}
#controls button:hover { border-color: #888; color: #fff; }
#controls button.active { border-color: #fff; color: #fff; background: rgba(255,255,255,0.08); }

/* ── playback bar ── */
#playbar {
  position: fixed;
  bottom: 0;
  left: 0;
  right: 0;
  z-index: 20;
  display: flex;
  align-items: center;
  gap: 0.7rem;
  padding: 0.6rem 1rem;
  background: rgba(0,0,0,0.7);
  backdrop-filter: blur(6px);
  -webkit-backdrop-filter: blur(6px);
  font-size: 0.7rem;
  transition: opacity 0.3s;
}
#playbar.hidden { opacity: 0; pointer-events: none; }

#playbar button {
  background: none;
  border: 1px solid #555;
  color: #ccc;
  font-family: inherit;
  font-size: 0.7rem;
  padding: 0.25rem 0.6rem;
  border-radius: 3px;
  cursor: pointer;
}
#playbar button:hover { border-color: #aaa; color: #fff; }

#seekbar {
  flex: 1;
  -webkit-appearance: none;
  appearance: none;
  height: 3px;
  background: #333;
  border-radius: 2px;
  outline: none;
  cursor: pointer;
}
#seekbar::-webkit-slider-thumb {
  -webkit-appearance: none;
  width: 10px;
  height: 10px;
  background: #fff;
  border-radius: 50%;
}
#timecode { color: #888; min-width: 5rem; text-align: right; }
#now-playing {
  font-size: 0.6rem;
  color: #555;
  max-width: 15rem;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

/* ── VR button override ── */
#vr-button-container {
  position: fixed;
  bottom: 3rem;
  left: 50%;
  transform: translateX(-50%);
  z-index: 25;
}
#vr-button-container button {
  font-family: 'SF Mono', 'Fira Code', monospace !important;
  font-size: 0.75rem !important;
  letter-spacing: 0.08em !important;
  border: 1px solid #555 !important;
  background: rgba(0,0,0,0.6) !important;
  color: #fff !important;
  padding: 0.6rem 1.5rem !important;
  border-radius: 4px !important;
}

/* ── info line ── */
#info {
  position: fixed;
  top: 0.6rem;
  left: 0.8rem;
  z-index: 20;
  font-size: 0.65rem;
  color: #555;
  letter-spacing: 0.05em;
}
</style>
</head>
<body>

<!-- UI overlay -->
<div id="ui">
  <h1>glitchVR</h1>

  <div id="gallery">
    <h2>renders</h2>
    <div class="video-list" id="video-list"></div>
  </div>

  <div id="dropzone">
    <p><span>or drop a local file</span></p>
    <input type="file" id="fileinput" accept="video/*" style="display:none">
  </div>

  <div id="controls">
    <button data-layout="sbs" class="active">SBS</button>
    <button data-layout="tb">Top-Bottom</button>
    <button data-layout="mono360">360&deg;</button>
    <button data-layout="sbs360">SBS 360&deg;</button>
    <button data-layout="flat">Flat</button>
  </div>
</div>

<!-- Playback bar -->
<div id="playbar" class="hidden">
  <button id="btn-play">play</button>
  <button id="btn-mute">unmute</button>
  <input type="range" id="seekbar" min="0" max="1000" value="0">
  <span id="timecode">00:00 / 00:00</span>
  <span id="now-playing"></span>
  <button id="btn-back">&larr; back</button>
</div>

<div id="info">glitchVR player</div>
<div id="vr-button-container"></div>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.172.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.172.0/examples/jsm/"
  }
}
</script>

<script type="module">
import * as THREE from 'three';
import { VRButton } from 'three/addons/webxr/VRButton.js';

// ── video catalog (loaded from catalog.json, generated from .nfo files) ──
let VIDEOS = [];

// ── state ──
let currentLayout = 'sbs';
let video = null;
let videoTexture = null;
let scene, camera, renderer;
let leftMesh = null, rightMesh = null, monoMesh = null, flatMesh = null;
let isPlaying = false;
let vrSession = false;

// ── DOM refs ──
const ui = document.getElementById('ui');
const dropzone = document.getElementById('dropzone');
const fileinput = document.getElementById('fileinput');
const playbar = document.getElementById('playbar');
const btnPlay = document.getElementById('btn-play');
const btnMute = document.getElementById('btn-mute');
const seekbar = document.getElementById('seekbar');
const timecodeEl = document.getElementById('timecode');
const nowPlaying = document.getElementById('now-playing');
const btnBack = document.getElementById('btn-back');
const layoutButtons = document.querySelectorAll('#controls button');
const vrContainer = document.getElementById('vr-button-container');
const videoListEl = document.getElementById('video-list');

// ── map glitch3d .nfo layout to WebXR display mode ──
function nfoLayoutToDisplay(v) {
  const layout = (v.layout || '').toLowerCase();
  const mode = (v.mode || '').toLowerCase();
  // equirect mode → 360° or stereo 360°
  if (mode === 'equirect') {
    return layout === 'sbs' ? 'sbs360' : 'mono360';
  }
  // stereo modes: sbs, tb, or anaglyph (anaglyph plays as flat)
  if (layout === 'tb' || layout === 'tab') return 'tb';
  if (layout === 'anaglyph') return 'flat';
  return 'sbs';
}

// ── populate gallery from catalog.json ──
async function loadCatalog() {
  try {
    const resp = await fetch('catalog.json');
    VIDEOS = await resp.json();
  } catch (e) {
    console.warn('No catalog.json found, gallery empty');
    return;
  }
  buildGallery();
}

function buildGallery() {
  videoListEl.innerHTML = '';
  VIDEOS.forEach(v => {
    const name = v.file.split('/').pop().replace('.mp4', '');
    const displayLayout = nfoLayoutToDisplay(v);
    const sourceLabel = v.source ? v.source.replace('.mp4', '') : '';
    const el = document.createElement('div');
    el.className = 'video-item';
    el.innerHTML = `
      <span class="v-name" title="${sourceLabel}">${v.version} &middot; ${sourceLabel || name}</span>
      <span class="v-quality ${v.quality}">${v.quality}</span>
      <span class="v-tag">${v.mode} ${v.layout}</span>
      <span class="v-size">${v.duration}</span>
      <span class="v-size">${v.size}</span>
    `;
    el.addEventListener('click', () => loadRemoteVideo(v.file, displayLayout, name));
    videoListEl.appendChild(el);
  });
}
loadCatalog();

// ── layout selector ──
layoutButtons.forEach(btn => {
  btn.addEventListener('click', () => {
    layoutButtons.forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    currentLayout = btn.dataset.layout;
    if (video) rebuildScene();
  });
});

// ── file input ──
dropzone.addEventListener('click', () => fileinput.click());
fileinput.addEventListener('change', e => {
  if (e.target.files.length) loadLocalVideo(e.target.files[0]);
});
dropzone.addEventListener('dragover', e => { e.preventDefault(); dropzone.classList.add('dragover'); });
dropzone.addEventListener('dragleave', () => dropzone.classList.remove('dragover'));
dropzone.addEventListener('drop', e => {
  e.preventDefault();
  dropzone.classList.remove('dragover');
  if (e.dataTransfer.files.length) loadLocalVideo(e.dataTransfer.files[0]);
});

// ── auto-detect layout from filename ──
function detectLayout(filename) {
  const f = filename.toLowerCase();
  if (f.includes('equirect') || f.includes('360')) {
    if (f.includes('sbs')) return 'sbs360';
    return 'mono360';
  }
  if (f.includes('_tb_') || f.includes('_tab_')) return 'tb';
  if (f.includes('_sbs_')) return 'sbs';
  return currentLayout;
}

function setLayout(layout) {
  currentLayout = layout;
  layoutButtons.forEach(b => b.classList.toggle('active', b.dataset.layout === layout));
}

// ── load remote (hosted) video ──
function loadRemoteVideo(url, layout, label) {
  setLayout(layout);
  startVideo(url, label);
}

// ── load local file ──
function loadLocalVideo(file) {
  setLayout(detectLayout(file.name));
  const url = URL.createObjectURL(file);
  startVideo(url, file.name.replace('.mp4', ''));
}

// ── shared video setup ──
function startVideo(src, label) {
  if (video) {
    video.pause();
    if (video.src.startsWith('blob:')) URL.revokeObjectURL(video.src);
  }

  video = document.createElement('video');
  video.crossOrigin = 'anonymous';
  video.loop = true;
  video.muted = true;
  video.playsInline = true;
  video.src = src;

  nowPlaying.textContent = label || '';

  video.addEventListener('loadedmetadata', () => {
    initThree();
    rebuildScene();
    video.play();
    isPlaying = true;
    btnPlay.textContent = 'pause';
    ui.classList.add('hidden');
    playbar.classList.remove('hidden');
  });

  video.addEventListener('error', () => {
    nowPlaying.textContent = 'error loading video';
  });
}

// ── Three.js init ──
function initThree() {
  if (renderer) return;

  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x000000);

  camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 2000);
  // Only enable layer 1 on main camera — desktop shows left eye as fallback.
  // In VR, Three.js ArrayCamera sets: left eye = layers 0+1, right eye = layers 0+2.
  // Enabling both layers here would render BOTH eyes to BOTH views = no stereo.
  camera.layers.enable(1);

  renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.xr.enabled = true;
  renderer.xr.setReferenceSpaceType('local');
  document.body.appendChild(renderer.domElement);

  const vrBtn = VRButton.createButton(renderer);
  vrContainer.appendChild(vrBtn);

  renderer.xr.addEventListener('sessionstart', () => { vrSession = true; });
  renderer.xr.addEventListener('sessionend', () => { vrSession = false; });

  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });

  // Mouse look (non-VR)
  let isDragging = false, prevX = 0, prevY = 0;
  let yaw = 0, pitch = 0;

  renderer.domElement.addEventListener('pointerdown', e => {
    isDragging = true;
    prevX = e.clientX;
    prevY = e.clientY;
  });
  window.addEventListener('pointerup', () => { isDragging = false; });
  window.addEventListener('pointermove', e => {
    if (!isDragging || vrSession) return;
    const dx = e.clientX - prevX;
    const dy = e.clientY - prevY;
    prevX = e.clientX;
    prevY = e.clientY;
    yaw -= dx * 0.003;
    pitch -= dy * 0.003;
    pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitch));
    camera.rotation.order = 'YXZ';
    camera.rotation.y = yaw;
    camera.rotation.x = pitch;
  });

  renderer.setAnimationLoop(() => {
    if (videoTexture) videoTexture.needsUpdate = true;
    renderer.render(scene, camera);
  });
}

// ── build/rebuild scene meshes ──
function rebuildScene() {
  [leftMesh, rightMesh, monoMesh, flatMesh].forEach(m => {
    if (m) { scene.remove(m); m.geometry.dispose(); m.material.dispose(); }
  });
  leftMesh = rightMesh = monoMesh = flatMesh = null;

  if (videoTexture) videoTexture.dispose();
  videoTexture = new THREE.VideoTexture(video);
  videoTexture.colorSpace = THREE.SRGBColorSpace;
  videoTexture.minFilter = THREE.LinearFilter;
  videoTexture.magFilter = THREE.LinearFilter;

  const layout = currentLayout;

  if (layout === 'flat') {
    buildFlat();
  } else if (layout === 'mono360') {
    buildSphere();
  } else if (layout === 'sbs') {
    buildStereoFlat('sbs');      // flat cinema screen, each eye sees its half
  } else if (layout === 'tb') {
    buildStereoFlat('tb');
  } else if (layout === 'sbs360') {
    buildStereoSphere('sbs');    // 360° sphere, each eye sees its half
  } else if (layout === 'tb360') {
    buildStereoSphere('tb');
  }
}

// ── mono 360° sphere ──
function buildSphere() {
  const geo = new THREE.SphereGeometry(500, 64, 32);
  geo.scale(-1, 1, 1);
  const mat = new THREE.MeshBasicMaterial({ map: videoTexture });
  monoMesh = new THREE.Mesh(geo, mat);
  monoMesh.rotation.y = -Math.PI / 2;
  monoMesh.layers.set(0);
  scene.add(monoMesh);
}

// ── stereo 360° sphere (for equirectangular SBS/TB) ──
function buildStereoSphere(stereoLayout) {
  const geoL = new THREE.SphereGeometry(500, 64, 32);
  geoL.scale(-1, 1, 1);
  const uvsL = geoL.attributes.uv.array;

  const geoR = new THREE.SphereGeometry(500, 64, 32);
  geoR.scale(-1, 1, 1);
  const uvsR = geoR.attributes.uv.array;

  if (stereoLayout === 'sbs') {
    for (let i = 0; i < uvsL.length; i += 2) { uvsL[i] *= 0.5; }
    for (let i = 0; i < uvsR.length; i += 2) { uvsR[i] *= 0.5; uvsR[i] += 0.5; }
  } else if (stereoLayout === 'tb') {
    for (let i = 0; i < uvsL.length; i += 2) { uvsL[i + 1] *= 0.5; }
    for (let i = 0; i < uvsR.length; i += 2) { uvsR[i + 1] *= 0.5; uvsR[i + 1] += 0.5; }
  }

  const matL = new THREE.MeshBasicMaterial({ map: videoTexture });
  const matR = new THREE.MeshBasicMaterial({ map: videoTexture });

  leftMesh = new THREE.Mesh(geoL, matL);
  leftMesh.rotation.y = -Math.PI / 2;
  leftMesh.layers.set(1);

  rightMesh = new THREE.Mesh(geoR, matR);
  rightMesh.rotation.y = -Math.PI / 2;
  rightMesh.layers.set(2);

  scene.add(leftMesh);
  scene.add(rightMesh);
}

// ── curved screen geometry ──
// Creates an inward-facing cylinder section — like an IMAX curved screen.
// Much more immersive than a flat plane for VR viewing.
function makeCurvedScreen(width, height, radius, segments) {
  radius = radius || 8;
  segments = segments || 64;
  // Arc angle the screen subtends
  const arc = width / radius;
  const halfArc = arc / 2;
  const halfH = height / 2;
  const segsX = segments;
  const segsY = Math.max(1, Math.round(segments * height / width));

  const positions = [];
  const uvs = [];
  const indices = [];

  for (let iy = 0; iy <= segsY; iy++) {
    const v = iy / segsY;
    const y = halfH - v * height;
    for (let ix = 0; ix <= segsX; ix++) {
      const u = ix / segsX;
      const angle = -halfArc + u * arc;
      // Cylinder surface, facing inward (camera at center)
      const x = radius * Math.sin(angle);
      const z = -radius * Math.cos(angle);
      positions.push(x, y, z);
      uvs.push(u, 1 - v);
    }
  }

  for (let iy = 0; iy < segsY; iy++) {
    for (let ix = 0; ix < segsX; ix++) {
      const a = iy * (segsX + 1) + ix;
      const b = a + 1;
      const c = a + (segsX + 1);
      const d = c + 1;
      indices.push(a, c, b);
      indices.push(b, c, d);
    }
  }

  const geo = new THREE.BufferGeometry();
  geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
  geo.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
  geo.setIndex(indices);
  return geo;
}

// ── stereo curved screen (for SBS/TB from rgb and temporal modes) ──
// Two overlapping curved screens. Left eye sees left half of the SBS frame,
// right eye sees right half. The RGB channel difference creates depth.
function buildStereoFlat(stereoLayout) {
  const frameW = video.videoWidth;
  const frameH = video.videoHeight;
  let eyeAspect;
  if (stereoLayout === 'sbs') {
    eyeAspect = (frameW / 2) / frameH;
  } else {
    eyeAspect = frameW / (frameH / 2);
  }

  const screenH = 8;
  const screenW = screenH * eyeAspect;
  const radius = 10;

  // Left eye screen
  const geoL = makeCurvedScreen(screenW, screenH, radius);
  const uvsL = geoL.attributes.uv.array;

  // Right eye screen
  const geoR = makeCurvedScreen(screenW, screenH, radius);
  const uvsR = geoR.attributes.uv.array;

  if (stereoLayout === 'sbs') {
    for (let i = 0; i < uvsL.length; i += 2) { uvsL[i] *= 0.5; }
    for (let i = 0; i < uvsR.length; i += 2) { uvsR[i] *= 0.5; uvsR[i] += 0.5; }
  } else if (stereoLayout === 'tb') {
    for (let i = 0; i < uvsL.length; i += 2) { uvsL[i + 1] *= 0.5; }
    for (let i = 0; i < uvsR.length; i += 2) { uvsR[i + 1] *= 0.5; uvsR[i + 1] += 0.5; }
  }

  const matL = new THREE.MeshBasicMaterial({ map: videoTexture, side: THREE.BackSide });
  const matR = new THREE.MeshBasicMaterial({ map: videoTexture, side: THREE.BackSide });

  leftMesh = new THREE.Mesh(geoL, matL);
  leftMesh.layers.set(1);  // Left eye only

  rightMesh = new THREE.Mesh(geoR, matR);
  rightMesh.layers.set(2); // Right eye only

  scene.add(leftMesh);
  scene.add(rightMesh);
}

// ── mono flat screen ──
function buildFlat() {
  const aspect = video.videoWidth / video.videoHeight;
  const screenH = 8;
  const screenW = screenH * aspect;
  const geo = makeCurvedScreen(screenW, screenH, 10);
  const mat = new THREE.MeshBasicMaterial({ map: videoTexture, side: THREE.BackSide });
  flatMesh = new THREE.Mesh(geo, mat);
  flatMesh.layers.set(0);
  scene.add(flatMesh);
}

// ── playback controls ──
btnPlay.addEventListener('click', () => {
  if (!video) return;
  if (isPlaying) { video.pause(); isPlaying = false; btnPlay.textContent = 'play'; }
  else { video.play(); isPlaying = true; btnPlay.textContent = 'pause'; }
});

btnMute.addEventListener('click', () => {
  if (!video) return;
  video.muted = !video.muted;
  btnMute.textContent = video.muted ? 'unmute' : 'mute';
});

seekbar.addEventListener('input', () => {
  if (!video || !video.duration) return;
  video.currentTime = (seekbar.value / 1000) * video.duration;
});

btnBack.addEventListener('click', () => {
  if (video) { video.pause(); isPlaying = false; }
  ui.classList.remove('hidden');
  playbar.classList.add('hidden');
});

// ── timecode update ──
function fmt(s) {
  const m = Math.floor(s / 60);
  const sec = Math.floor(s % 60);
  return `${String(m).padStart(2,'0')}:${String(sec).padStart(2,'0')}`;
}

setInterval(() => {
  if (!video || !video.duration) return;
  seekbar.value = (video.currentTime / video.duration) * 1000;
  timecodeEl.textContent = `${fmt(video.currentTime)} / ${fmt(video.duration)}`;
}, 250);

// ── URL param support: ?src=video.mp4&layout=sbs ──
const params = new URLSearchParams(location.search);
if (params.get('src')) {
  const srcUrl = params.get('src');
  const layout = params.get('layout') || 'sbs';
  loadRemoteVideo(srcUrl, layout, srcUrl.split('/').pop());
}
</script>
</body>
</html>
